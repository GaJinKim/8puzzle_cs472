    public void breadthFirstSearch(Node problem) {
        boolean foundSolution = false;
        long startTime = System.currentTimeMillis();

        Set<char[]> closed = new HashSet<char[]>(); // closed list (explored set)
        Queue<Node> fringe = new LinkedList<Node>(); // open list (not yet explored set)
        fringe.add(problem);

        outerloop:
        while (!fringe.isEmpty() && System.currentTimeMillis() - startTime < fifteenMinInMilliseconds) {
            Node current = fringe.poll(); // pop() equivalent
            closed.add(current.getState());

            List<Node> successors = Successor.getSuccessors(current);
            totalNodes += successors.size();

            for (Node child : successors) {
                if (closed.contains(child.getState()))
                    continue;

                // child state is not in closed or fringe
                if (!(closed.contains(child.getState()) || fringe.contains(child))) {
                    if (atGoalState(child)) {
                        printSolution(totalNodes, System.currentTimeMillis() - startTime, child);
                        foundSolution = true;
                        break outerloop;
                    }
                    fringe.add(child);
                }
            }
        }
        if (!foundSolution) {
            printTimeout();
        }
    }